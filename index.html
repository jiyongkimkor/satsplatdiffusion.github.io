<!DOCTYPE html>
<html>
<head>
    <title>SatSplat: PLY Comparison</title>
    <script type="module">
        import * as SPLAT from "https://cdn.skypack.dev/gsplat@1.2.0";

        let rendererA, rendererB, sceneA, sceneB, cameraA, cameraB, controlsA;
        
        // Default models from Hugging Face (Use direct download links)
        const MODEL_A_DEFAULT = "https://huggingface.co/datasets/jiyong1591/SatSplatDiffusion/resolve/main/JAX_068_step1_baked.ply?download=true";
        const MODEL_B_DEFAULT = "https://huggingface.co/datasets/jiyong1591/SatSplatDiffusion/resolve/main/JAX_068_step2_baked.ply?download=true";

        /**
         * Robust model loader that handles redirects and forces file extension recognition.
         */
        async function loadModel(url, scene) {
            scene.reset(); // Clear existing scene data

            // 1. Fetch data manually to handle potential CORS/Redirect issues
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            
            const blob = await response.blob();

            // 2. Wrap blob in a File object to explicitly provide the extension.
            // gsplat.js uses the file extension to determine the correct parser (PLY vs SPLAT).
            const isPly = url.toLowerCase().includes(".ply");
            const fileName = isPly ? "model.ply" : "model.splat";
            const file = new File([blob], fileName, { type: blob.type });

            // 3. Load from the File object
            const obj = await SPLAT.Loader.LoadAsync(file, scene);
            
            // 4. Force centering the model data
            const data = obj.data || (obj.splat && obj.splat.data);
            if (data && data.positions) {
                const pos = data.positions;
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                
                // Calculate bounding box
                for (let i = 0; i < pos.length; i += 3) {
                    minX = Math.min(minX, pos[i]); maxX = Math.max(maxX, pos[i]);
                    minY = Math.min(minY, pos[i+1]); maxY = Math.max(maxY, pos[i+1]);
                    minZ = Math.min(minZ, pos[i+2]); maxZ = Math.max(maxZ, pos[i+2]);
                }
                
                // Calculate center point
                const cX = (minX + maxX) / 2;
                const cY = (minY + maxY) / 2;
                const cZ = (minZ + maxZ) / 2;
                
                // Shift all points to origin (0,0,0)
                for (let i = 0; i < pos.length; i += 3) {
                    pos[i] -= cX; pos[i+1] -= cY; pos[i+2] -= cZ;
                }
            }
            // Align coordinate system (Z-up to Y-up)
            obj.rotation = SPLAT.Quaternion.FromEuler(new SPLAT.Vector3(Math.PI / 2, 0, 0));
        }

        async function main() {
            const canvasA = document.getElementById("canvasA");
            const canvasB = document.getElementById("canvasB");

            sceneA = new SPLAT.Scene();
            sceneB = new SPLAT.Scene();
            cameraA = new SPLAT.Camera();
            cameraB = new SPLAT.Camera();

            rendererA = new SPLAT.WebGLRenderer(canvasA);
            rendererB = new SPLAT.WebGLRenderer(canvasB);

            // Responsive viewport handling
            const resize = () => {
                const w = (window.innerWidth - 250) / 2;
                const h = window.innerHeight;
                rendererA.setSize(w, h, Math.min(window.devicePixelRatio, 1.5));
                rendererB.setSize(w, h, Math.min(window.devicePixelRatio, 1.5));
            };
            window.addEventListener("resize", resize);
            resize();

            // Initialize OrbitControls on the left viewport
            controlsA = new SPLAT.OrbitControls(cameraA, canvasA);
            
            // Set initial camera position (Override defaults)
            cameraA.position = new SPLAT.Vector3(0.75, -1.5, 0.0);
            controlsA.setCameraTarget(new SPLAT.Vector3(0, 0, 0));
            controlsA.update();

            // Initial model loading from URLs
            document.getElementById("status").innerText = "Downloading Models...";
            try {
                await Promise.all([
                    loadModel(MODEL_A_DEFAULT, sceneA),
                    loadModel(MODEL_B_DEFAULT, sceneB)
                ]);
                document.getElementById("status").innerText = "Step 1 vs Step 2 Loaded";
            } catch (err) {
                console.error(err);
                document.getElementById("status").innerText = "Load Error. Check Console.";
            }

            // UI Listeners for local file uploads
            document.getElementById('fileA').onchange = async (e) => {
                const url = URL.createObjectURL(e.target.files[0]);
                await loadModel(url, sceneA);
            };
            document.getElementById('fileB').onchange = async (e) => {
                const url = URL.createObjectURL(e.target.files[0]);
                await loadModel(url, sceneB);
            };

            // Unified rendering loop
            const frame = () => {
                controlsA.update();
                
                // Synchronize Camera B with Camera A's state for identical viewing angle
                cameraB.position = cameraA.position.clone();
                cameraB.rotation = cameraA.rotation.clone();

                rendererA.render(sceneA, cameraA);
                rendererB.render(sceneB, cameraB);
                requestAnimationFrame(frame);
            };
            requestAnimationFrame(frame);
        }

        main();
    </script>
    <style>
        body { margin: 0; display: flex; background: #000; color: white; font-family: 'Segoe UI', Tahoma, sans-serif; overflow: hidden; }
        #sidebar { width: 250px; background: #111; padding: 20px; border-right: 1px solid #333; box-shadow: 2px 0 10px rgba(0,0,0,0.5); display: flex; flex-direction: column; }
        #viewer-container { flex: 1; display: flex; gap: 2px; background: #222; }
        canvas { width: 50%; height: 100vh; background: #000; cursor: crosshair; }
        .upload-box { margin-bottom: 20px; padding: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; }
        h3 { color: #4AF; font-size: 1.1em; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; }
        #status { font-size: 0.85em; color: #888; margin-bottom: 20px; display: block; font-style: italic; }
        label { font-size: 0.75em; color: #4AF; font-weight: bold; text-transform: uppercase; }
        input[type="file"] { width: 100%; margin-top: 8px; font-size: 0.8em; color: #666; cursor: pointer; }
        .controls-info { font-size: 0.75em; color: #444; margin-top: auto; line-height: 1.6; border-top: 1px solid #222; padding-top: 20px; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h3>SatSplat View</h3>
        <span id="status">Initializing...</span>
        
        <div class="upload-box">
            <label>Left: Step 1 (Baked)</label>
            <input type="file" id="fileA" accept=".ply,.splat">
        </div>
        
        <div class="upload-box">
            <label>Right: Step 2 (Baked)</label>
            <input type="file" id="fileB" accept=".ply,.splat">
        </div>

        <div class="controls-info">
            <strong>[Mouse Controls]</strong><br>
            • Left Drag: Orbit/Rotate<br>
            • Right Drag: Pan/Move<br>
            • Scroll: Zoom In/Out<br><br>
            Views are synchronized.
        </div>
    </div>
    <div id="viewer-container">
        <canvas id="canvasA"></canvas>
        <canvas id="canvasB"></canvas>
    </div>
</body>
</html>
